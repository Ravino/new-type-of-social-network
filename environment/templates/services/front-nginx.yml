AWSTemplateFormatVersion: '2010-09-09'
Description: ECS Service managed with Fargate launch type

Parameters:
  # application configuration
  EnvironmentName:
    Type: String
    Default: test
    Description: A name for the environment that this cloudformation will be part of.
                 Used to locate other resources in the same environment.
    AllowedValues:
      - test
      - prod
    ConstraintDescription: Environment name may be only 'test' or 'prod', to prevent
                           configuration files multiplication.
  # stack-related parameters
  # application configuration
  ServiceName:
    Type: String
    Default: service
    Description: A name for the service that would be managing FARGATE tasks inside the cluster.
  # deployment
  ImageUrl:
    Type: String
    Default: 'busybox'
    Description: The url of a docker image that contains the application process that
                 will handle the traffic for this service
  # deployment
  ContainerPort:
    Type: Number
    Default: 80
    Description: What port number the application the docker container is binding to
  # deployment
  ServiceProtocol:
    Type: String
    Default: HTTP
    Description: Which protocol should be used for service communication
    AllowedValues:
      - HTTP
      - HTTPS
      - TCP
      - TLS
      - UDP
    ConstraintDescription: Only existing internet protocol should be specified as service protocol
  # # deployment
  # ContainerPortAdmin:
  #   Type: Number
  #   Default: 81
  #   Description: What port number the application the docker container is binding to
  # # deployment
  # ServiceProtocolAdmin:
  #   Type: String
  #   Default: HTTP
  #   Description: Which protocol should be used for service communication
  #   AllowedValues:
  #     - HTTP
  #     - HTTPS
  #     - TCP
  #     - TLS
  #     - UDP
  #   ConstraintDescription: Only existing internet protocol should be specified as service protocol
  # resources management
  ContainerCpu:
    Type: Number
    Default: 256
    Description: How much CPU to give the container. 1024 is 1 CPU
  # resources management
  ContainerMemory:
    Type: Number
    Default: 512
    Description: How much memory in megabytes to give the container
  # load balancing
  Path:
    Type: String
    Description: A path on the load balancer that this service
                 should be connected to. Use * to send all load balancer
                 traffic to this service.
  # load balancing
  Priority:
    Type: Number
    Default: 1
    Description: The priority for the routing rule added to the load balancer.
                 This only applies if your have multiple services which have been
                 assigned to different paths on the load balancer.
  # auto-scaling
  MinCapacity:
    Type: Number
    Default: 1
    Description: How many copies is min setupped to run
  # auto-scaling
  DesiredCount:
    Type: Number
    Default: 1
    Description: How many copies of the service task to run
  # auto-scaling
  MaxCapacity:
    Type: Number
    Default: 5
    Description: How many copies is max allowed to run
  # auto-scaling
  LowCpuPeriodAlarm:
    Type: Number
    Default: 300
    Description: Period length (in seconds) that limit value encounters as once noticed
  # auto-scaling
  ScaleDownCooldown:
    Type: Number
    Default: 300
    Description: Cooldown before next scaling down
  # auto-scaling
  LowCpuThresholdAlarm:
    Type: Number
    Default: 20
    Description: Limit value that indicates, that alarm action should be applied
  # auto-scaling
  HighCpuPeriodAlarm:
    Type: Number
    Default: 60
    Description: Period length (in seconds) that limit value encounters as once noticed
  # auto-scaling
  HighCpuThresholdAlarm:
    Type: Number
    Default: 70
    Description: Limit value that indicates, that alarm action should be applied
  # auto-scaling
  ScaleUpCooldown:
    Type: Number
    Default: 30
    Description: Cooldown before next scaling up
  # deployment
  DeploymentMaximum:
    Type: Number
    Default: 200
    Description: Maximum percent parameter represents an upper limit on the number of tasks in a service
               that are allowed in the RUNNING or PENDING state during a deployment,
               as a percentage of the desired number of tasks
  # deployment
  DeploymentMinimum:
    Type: Number
    Default: 100
    Description: Minimum healthy percent represents a lower limit on the number of tasks in a service
                that must remain in the RUNNING state during a deployment, as a percentage of
                the desired number of tasks (rounded up to the nearest integer)
  #Role:
  #  Type: String
  #  Default: ""
  #  Description: (Optional) An IAM role to give the service's containers if the code within needs to
  #              access other AWS resources like S3 buckets, DynamoDB tables, etc
#Conditions:
#  HasCustomRole: !Not [ !Equals [!Ref 'Role', ''] ]
Resources:
  # A log group for storing the container logs for this service
  LogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Join ['-', [!Ref 'EnvironmentName', 'public', !Ref 'ServiceName']]

  # The task definition. This is a simple metadata description of what
  # container to run, and what resource requirements it has.
  TaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !Ref 'ServiceName'
      Cpu: !Ref 'ContainerCpu'
      Memory: !Ref 'ContainerMemory'
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      ExecutionRoleArn:
        Fn::ImportValue:
          !Join [':', [!Ref 'EnvironmentName', 'ECSTaskExecutionRole']]
      TaskRoleArn:
        Fn::ImportValue:
          !Join [':', [!Ref 'EnvironmentName', 'ECSServiceExecutionTaskRole']]
      ContainerDefinitions:
        - Name: !Ref 'ServiceName'
          Cpu: !Ref 'ContainerCpu'
          Memory: !Ref 'ContainerMemory'
          Image: !Ref 'ImageUrl'
          #Environment:
          PortMappings:
            - ContainerPort: !Ref 'ContainerPort'
            # - ContainerPort: !Ref 'ContainerPortAdmin'
          LogConfiguration:
            LogDriver: 'awslogs'
            Options:
              awslogs-group: !Join ['-', [!Ref 'EnvironmentName', 'public', !Ref 'ServiceName']]
              awslogs-region: !Ref 'AWS::Region'
              awslogs-stream-prefix: !Ref 'ServiceName'

  # The service. The service is a resource which allows you to run multiple
  # copies of a type of task, and gather up their logs and metrics, as well
  # as monitor the number of running tasks and replace any that have crashed
  Service:
    Type: AWS::ECS::Service
    DependsOn:
      - ListenerRule
      - ListenerRuleSSL
    Properties:
      ServiceName: !Ref 'ServiceName'
      Cluster:
        Fn::ImportValue:
          !Join [':', [!Ref 'EnvironmentName', 'ClusterName']]
      LaunchType: FARGATE
      PlatformVersion: "1.4.0"
      DeploymentConfiguration:
        MaximumPercent: !Ref DeploymentMaximum
        MinimumHealthyPercent: !Ref DeploymentMinimum
      DesiredCount: !Ref 'DesiredCount'
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
            - Fn::ImportValue:
                !Join [':', [!Ref 'EnvironmentName', 'FargateContainerSecurityGroup']]
          Subnets:
            - Fn::ImportValue:
                !Join [':', [!Ref 'EnvironmentName', 'PublicSubnetOne']]
            - Fn::ImportValue:
                !Join [':', [!Ref 'EnvironmentName', 'PublicSubnetTwo']]
      TaskDefinition: !Ref 'TaskDefinition'
      HealthCheckGracePeriodSeconds: 2147483647
      LoadBalancers:
        - ContainerName: !Ref 'ServiceName'
          ContainerPort: 80
          TargetGroupArn: !Ref 'TargetGroup'
        # - ContainerName: !Ref 'ServiceName'
        #   ContainerPort: 81
        #   TargetGroupArn: !Ref 'TargetGroupAdmin'
  # A target group. This is used for keeping track of all the tasks, and
  # what IP addresses / port numbers they have. You can query it yourself,
  # to use the addresses yourself, but most often this target group is just
  # connected to an application load balancer, or network load balancer, so
  # it can automatically distribute traffic across all the targets.
  TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      # HealthCheckIntervalSeconds: 30
      # HealthCheckPath: /
      # HealthCheckProtocol: HTTPS
      # HealthCheckTimeoutSeconds: 5
      # HealthyThresholdCount: 2
      # Matcher:
      #   HttpCode: "200-299"
      TargetType: ip
      Name: !Ref 'ServiceName'
      Port: !Ref 'ContainerPort'
      Protocol: !Ref 'ServiceProtocol'
      # TargetGroupAttributes:
      #   - Key: stickiness.enabled
      #     Value: 'true' # TODO possible reason of issues for WebSockets are not forwarding messages
      #   - Key: deregistration_delay.timeout_seconds
      #     Value: '30' # TODO possible reason of issues for WebSockets are not forwarding messages
      #UnhealthyThresholdCount: 2
      VpcId:
        Fn::ImportValue:
          !Join [':', [!Ref 'EnvironmentName', 'VPCId']]
  # TargetGroupAdmin:
  #   Type: AWS::ElasticLoadBalancingV2::TargetGroup
  #   Properties:
  #     HealthCheckIntervalSeconds: 6
  #     HealthCheckPath: /
  #     HealthCheckProtocol: HTTP
  #     HealthCheckTimeoutSeconds: 5
  #     HealthyThresholdCount: 2
  #     Matcher:
  #       HttpCode: "200-299"
  #     TargetType: ip
  #     Name: !Join ["-", [ !Ref 'ServiceName', "Admin" ] ]
  #     Port: !Ref 'ContainerPortAdmin'
  #     Protocol: !Ref 'ServiceProtocolAdmin'
  #     TargetGroupAttributes:
  #       - Key: stickiness.enabled
  #         Value: 'true' # TODO possible reason of issues for WebSockets are not forwarding messages
  #       - Key: deregistration_delay.timeout_seconds
  #         Value: '30' # TODO possible reason of issues for WebSockets are not forwarding messages
  #     UnhealthyThresholdCount: 2
  #     VpcId:
  #       Fn::ImportValue:
  #         !Join [':', [!Ref 'EnvironmentName', 'VPCId']]

  # Create a rule on the load balancer for routing traffic to the target group
 # Create rules to forward both HTTP and HTTPS traffic to the service's
  # target group. The service itself will handle redirecting HTTP traffic
  # to HTTPS
  ListenerRule:
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      Actions:
        - TargetGroupArn: !Ref 'TargetGroup'
          Type: 'forward'
      Conditions:
        - Field: host-header
          Values: [!Ref 'Path']
      ListenerArn:
        Fn::ImportValue:
          !Join [':', [!Ref 'EnvironmentName', 'ALBListenerNginx']]
      Priority: !Ref 'Priority'
  ListenerRuleSSL:
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      Actions:
        - TargetGroupArn: !Ref 'TargetGroup'
          Type: 'forward'
      Conditions:
        - Field: host-header
          Values: [!Ref 'Path']
      ListenerArn:
        Fn::ImportValue:
          !Join [':', [!Ref 'EnvironmentName', 'ALBListenerNginxSSL']]
      Priority: !Ref 'Priority'
  # ListenerRuleAdmin:
  #   Type: AWS::ElasticLoadBalancingV2::ListenerRule
  #   Properties:
  #     Actions:
  #       - TargetGroupArn: !Ref 'TargetGroupAdmin'
  #         Type: 'forward'
  #     Conditions:
  #       - Field: host-header
  #         Values: [!Ref 'Path']
  #     ListenerArn:
  #       Fn::ImportValue:
  #         !Join [':', [!Ref 'EnvironmentName', 'ALBListenerNginxAdmin']]
  #     Priority: !Ref 'Priority'

  # Enable autoscaling for this service
  ScalableTarget:
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    DependsOn: Service
    Properties:
      ServiceNamespace: 'ecs'
      ScalableDimension: 'ecs:service:DesiredCount'
      ResourceId:
        Fn::Join:
          - '/'
          - - service
            - Fn::ImportValue: !Join [':', [!Ref 'EnvironmentName', 'ClusterName']]
            - !Ref 'ServiceName'
      MinCapacity: !Ref MinCapacity
      MaxCapacity: !Ref MaxCapacity
      RoleARN:
        Fn::ImportValue:
          !Join [':', [!Ref 'EnvironmentName', 'AutoscalingRole']]

  # Create scaling policies for the service
  ScaleDownPolicy:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    DependsOn: ScalableTarget
    Properties:
      PolicyName:
        Fn::Join:
          - '/'
          - - scale
            - !Ref 'EnvironmentName'
            - !Ref 'ServiceName'
            - down
      PolicyType: StepScaling
      ResourceId:
        Fn::Join:
          - '/'
          - - service
            - Fn::ImportValue: !Join [':', [!Ref 'EnvironmentName', 'ClusterName']]
            - !Ref 'ServiceName'
      ScalableDimension: 'ecs:service:DesiredCount'
      ServiceNamespace: 'ecs'
      StepScalingPolicyConfiguration:
        AdjustmentType: 'ChangeInCapacity'
        StepAdjustments:
          - MetricIntervalUpperBound: 0
            ScalingAdjustment: -1
        MetricAggregationType: 'Average'
        Cooldown: !Ref ScaleDownCooldown

  ScaleUpPolicy:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    DependsOn: ScalableTarget
    Properties:
      PolicyName:
        Fn::Join:
          - '/'
          - - scale
            - !Ref 'EnvironmentName'
            - !Ref 'ServiceName'
            - up
      PolicyType: StepScaling
      ResourceId:
        Fn::Join:
          - '/'
          - - service
            - Fn::ImportValue: !Join [':', [!Ref 'EnvironmentName', 'ClusterName']]
            - !Ref 'ServiceName'
      ScalableDimension: 'ecs:service:DesiredCount'
      ServiceNamespace: 'ecs'
      StepScalingPolicyConfiguration:
        AdjustmentType: 'ChangeInCapacity'
        StepAdjustments:
          - MetricIntervalLowerBound: 0
            MetricIntervalUpperBound: 15
            ScalingAdjustment: 1
          - MetricIntervalLowerBound: 15
            MetricIntervalUpperBound: 25
            ScalingAdjustment: 2
          - MetricIntervalLowerBound: 25
            ScalingAdjustment: 3
        MetricAggregationType: 'Average'
        Cooldown: !Ref ScaleUpCooldown

  # Create alarms to trigger these policies
  LowCpuUsageAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName:
        Fn::Join:
          - '-'
          - - low-cpu
            - !Ref 'EnvironmentName'
            - !Ref 'ServiceName'
      AlarmDescription:
        Fn::Join:
          - ' '
          - - "Low CPU utilization for service"
            - !Ref 'ServiceName'
            - "in stack"
            - !Ref 'EnvironmentName'
      MetricName: CPUUtilization
      Namespace: AWS/ECS
      Dimensions:
        - Name: ServiceName
          Value: !Ref 'ServiceName'
        - Name: ClusterName
          Value:
            Fn::ImportValue: !Join [':', [!Ref 'EnvironmentName', 'ClusterName']]
      Statistic: Average
      Period: !Ref LowCpuPeriodAlarm
      EvaluationPeriods: 1
      Threshold: !Ref LowCpuThresholdAlarm
      ComparisonOperator: LessThanOrEqualToThreshold
      AlarmActions:
        - !Ref ScaleDownPolicy

  HighCpuUsageAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName:
        Fn::Join:
          - '-'
          - - high-cpu
            - !Ref 'EnvironmentName'
            - !Ref 'ServiceName'
      AlarmDescription:
        Fn::Join:
          - ' '
          - - "High CPU utilization for service"
            - !Ref 'ServiceName'
            - "in stack"
            - !Ref 'EnvironmentName'
      MetricName: CPUUtilization
      Namespace: AWS/ECS
      Dimensions:
        - Name: ServiceName
          Value: !Ref 'ServiceName'
        - Name: ClusterName
          Value:
            Fn::ImportValue: !Join [':', [!Ref 'EnvironmentName', 'ClusterName']]
      Statistic: Average
      Period: !Ref HighCpuPeriodAlarm
      EvaluationPeriods: 1
      Threshold: !Ref HighCpuThresholdAlarm
      ComparisonOperator: GreaterThanOrEqualToThreshold
      AlarmActions:
        - !Ref ScaleUpPolicy
